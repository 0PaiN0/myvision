import { getAllImageData } from '../../../imageList/imageList';
import { drawShapesViaCoordinates } from '../../../toolkit/buttonClickEvents/facadeWorkersUtils/drawShapesViaCoordinates/drawShapesViaCoordinates';
import { getCurrentImageId, setChangingMLGeneratedLabelNamesState } from '../../../toolkit/buttonClickEvents/facadeWorkersUtils/stateManager';
import {
  displayErrorMessage, updateProgressMessage, removeStartButton, removeCancelButton,
  disableStartButton, displayNoImagesFoundError, displayContinueButton, displayLoaderWheel,
} from './style';

let tfModel = null;

function errorHandler() {
  displayErrorMessage('ERROR! Please try again later.');
}

const predictedImageCoordinates = {};

function predict(image) {
  return tfModel.detect(image.data);
}

// check overflow
// paste

// two use cases to do UX for; 1 - map the names before generating, 2 - cancel, keep, continue

/*
let stopState = false;

function stopAPromiseAll() {
  stopState = true;
}

function predict(image) {
  return new Promise((resolve, reject) => {
    if (!stopState) {
      tfModel.detect(image.data).then((result) => {resolve(result)});
      // check if we don't need to do .catch((error) => reject(error));
    } else {
      reject();
    }
  });
}

// check if catch works
*/

// TEST
// check that only the images that have been checked have their shapes regenerated

// TEST
// check if it is not too early to display finished as the images still need to
// be updated with shapes

// can cancel on 2 parts, 1 in getting the script, 2 in predicting

function changeGeneratedShapeLabels(doneCallback, setMachineLearningData) {
  const predictionsObject = {"0":[{"bbox":[0.23196187615394592,1.3171005249023438,282.11527583003044,337.3044550418854],"class":"cat","score":0.8860134482383728}],"1":[{"bbox":[16.03703498840332,194.2115306854248,1113.8134002685547,482.022762298584],"class":"car","score":0.9936941266059875},{"bbox":[1233.7510585784912,1169.7566986083984,1080.3159713745117,385.3567123413086],"class":"car","score":0.9841077327728271},{"bbox":[96.5882420539856,1009.1146469116211,1040.1406645774841,506.1511993408203],"class":"truck","score":0.9241188764572144},{"bbox":[1270.0901985168457,110.06307601928711,1079.1927337646484,524.1976737976074],"class":"car","score":0.8551244735717773}]};
  setMachineLearningData(predictionsObject);
  doneCallback();
  // const objectNames = {};
  Object.keys(predictionsObject).forEach((key) => {
    const predictions = predictionsObject[key];
    // objectNames[key] = {};
    for (let i = 0; i < predictions.length; i += 1) {
    //   objectNames[key].class = predictions[i].class
    }
  });
}

function executeAndRecordPredictionResults(promisesArray, predictionIdToImageId,
  doneCallback, setMachineLearningData) {
  Promise.all(promisesArray)
    .catch(() => {
      // if stopstate = true
      // else display an error
      console.log('error');
      // should return the completed array promises
      return promisesArray;
    })
    // TEST
    // check to see if only the completed operations are returned and should
    // there be more work needed to match the IDs
    .then((predictions) => {
      for (let i = 0; i < predictions.length; i += 1) {
        predictedImageCoordinates[predictionIdToImageId[i]] = predictions[i];
      }
      console.log('called');
      
      // setMachineLearningData(predictedImageCoordinates);
      // doneCallback();
      displayContinueButton();
      removeCancelButton();
      drawShapesViaCoordinates(predictedImageCoordinates);
      updateProgressMessage('Finished!');
      // timeout here and then move to next, or use a different callback to style.js and
      // display a button (with registered handler) to continue and call doneCallback
    });
}

// TEST
// check that the current image shapes are being regenerated by the model

// decided not to store generated shapes because if you have 100 images with
// 100s of shapes, it would lead to significant memory usage
function makePredictionsForAllImages(doneCallback, setMachineLearningData) {
  const predictPromises = [];
  const allImageData = getAllImageData();
  const predictionIdToImageId = [];
  const currentImageId = getCurrentImageId();
  for (let i = 0; i < allImageData.length; i += 1) {
    const image = allImageData[i];
    if (image.numberOfMLGeneratedShapes === 0) {
      predictPromises.push(predict(image));
      predictionIdToImageId.push(i);
    } else if (i === currentImageId) {
      predictPromises.push(predict(image));
      predictionIdToImageId.push(i);
    }
  }
  executeAndRecordPredictionResults(predictPromises, predictionIdToImageId,
    doneCallback, setMachineLearningData);
}

function loadModel() {
  return new Promise((resolve, reject) => {
    const { cocoSsd } = window;
    cocoSsd.load().then((model) => {
      tfModel = model;
      resolve();
    }).catch(() => {
      reject();
    });
  });
}

function downloadCOCOSSD() {
  return new Promise((resolve, reject) => {
    const cocoSSDScript = document.createElement('script');
    cocoSSDScript.onload = resolve;
    cocoSSDScript.onerror = reject;
    cocoSSDScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd';
    document.head.appendChild(cocoSSDScript);
  });
}

function downloadTensorflowJS() {
  return new Promise((resolve, reject) => {
    // loading spinner, maybe something funky with ML?
    // disableStartButton();
    displayLoaderWheel();
    removeStartButton();
    const tensorflowJSScript = document.createElement('script');
    tensorflowJSScript.onload = resolve;
    tensorflowJSScript.onerror = reject;
    tensorflowJSScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs';
    document.head.appendChild(tensorflowJSScript);
  });
}

function startMachineLearning(doneCallback, setMachineLearningData) {
  // changeGeneratedShapeLabels(doneCallback, setMachineLearningData);
  setChangingMLGeneratedLabelNamesState(true);
  const allImageData = getAllImageData();
  if (allImageData.length > 0) {
    if (!tfModel) {
      downloadTensorflowJS()
        .then(() => downloadCOCOSSD())
        .then(() => loadModel())
        .then(() => makePredictionsForAllImages(doneCallback, setMachineLearningData))
        .catch(() => errorHandler());
    } else {
      makePredictionsForAllImages(doneCallback, setMachineLearningData);
    }
  } else {
    displayNoImagesFoundError();
  }
}

export { startMachineLearning as default };
